{"ast":null,"code":"import * as cbor from './cbor';\nimport { AgentError } from './errors';\nimport { hash } from './request_id';\nimport { concat, fromHex, toHex } from './utils/buffer';\nimport { Principal } from '@dfinity/principal';\nimport * as bls from './utils/bls';\nimport { decodeTime } from './utils/leb';\n/**\n * A certificate may fail verification with respect to the provided public key\n */\nexport class CertificateVerificationError extends AgentError {\n  constructor(reason) {\n    super(`Invalid certificate: ${reason}`);\n  }\n}\n/**\n * Make a human readable string out of a hash tree.\n * @param tree\n */\nexport function hashTreeToString(tree) {\n  const indent = s => s.split('\\n').map(x => '  ' + x).join('\\n');\n  function labelToString(label) {\n    const decoder = new TextDecoder(undefined, {\n      fatal: true\n    });\n    try {\n      return JSON.stringify(decoder.decode(label));\n    } catch (e) {\n      return `data(...${label.byteLength} bytes)`;\n    }\n  }\n  switch (tree[0]) {\n    case 0 /* NodeId.Empty */:\n      return '()';\n    case 1 /* NodeId.Fork */:\n      {\n        const left = hashTreeToString(tree[1]);\n        const right = hashTreeToString(tree[2]);\n        return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n      }\n    case 2 /* NodeId.Labeled */:\n      {\n        const label = labelToString(tree[1]);\n        const sub = hashTreeToString(tree[2]);\n        return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n      }\n    case 3 /* NodeId.Leaf */:\n      {\n        return `leaf(...${tree[1].byteLength} bytes)`;\n      }\n    case 4 /* NodeId.Pruned */:\n      {\n        return `pruned(${toHex(new Uint8Array(tree[1]))}`;\n      }\n    default:\n      {\n        return `unknown(${JSON.stringify(tree[0])})`;\n      }\n  }\n}\nfunction isBufferEqual(a, b) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  const a8 = new Uint8Array(a);\n  const b8 = new Uint8Array(b);\n  for (let i = 0; i < a8.length; i++) {\n    if (a8[i] !== b8[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport class Certificate {\n  constructor(certificate, _rootKey, _canisterId, _blsVerify) {\n    let _maxAgeInMinutes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 5;\n    this._rootKey = _rootKey;\n    this._canisterId = _canisterId;\n    this._blsVerify = _blsVerify;\n    this._maxAgeInMinutes = _maxAgeInMinutes;\n    this.cert = cbor.decode(new Uint8Array(certificate));\n  }\n  /**\n   * Create a new instance of a certificate, automatically verifying it. Throws a\n   * CertificateVerificationError if the certificate cannot be verified.\n   * @constructs  Certificate\n   * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}\n   * @param {ArrayBuffer} options.certificate The bytes of the certificate\n   * @param {ArrayBuffer} options.rootKey The root key to verify against\n   * @param {Principal} options.canisterId The effective or signing canister ID\n   * @param {number} options.maxAgeInMinutes The maximum age of the certificate in minutes. Default is 5 minutes.\n   * @throws {CertificateVerificationError}\n   */\n  static async create(options) {\n    let blsVerify = options.blsVerify;\n    if (!blsVerify) {\n      blsVerify = bls.blsVerify;\n    }\n    const cert = new Certificate(options.certificate, options.rootKey, options.canisterId, blsVerify, options.maxAgeInMinutes);\n    await cert.verify();\n    return cert;\n  }\n  lookup(path) {\n    return lookup_path(path, this.cert.tree);\n  }\n  async verify() {\n    const rootHash = await reconstruct(this.cert.tree);\n    const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);\n    const sig = this.cert.signature;\n    const key = extractDER(derKey);\n    const msg = concat(domain_sep('ic-state-root'), rootHash);\n    let sigVer = false;\n    const lookupTime = this.lookup(['time']);\n    if (!lookupTime) {\n      // Should never happen - time is always present in IC certificates\n      throw new CertificateVerificationError('Certificate does not contain a time');\n    }\n    const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n    const MAX_AGE_IN_MSEC = this._maxAgeInMinutes * 60 * 1000;\n    const now = Date.now();\n    const earliestCertificateTime = now - MAX_AGE_IN_MSEC;\n    const fiveMinutesFromNow = now + FIVE_MINUTES_IN_MSEC;\n    const certTime = decodeTime(lookupTime);\n    if (certTime.getTime() < earliestCertificateTime) {\n      throw new CertificateVerificationError(`Certificate is signed more than ${this._maxAgeInMinutes} minutes in the past. Certificate time: ` + certTime.toISOString() + ' Current time: ' + new Date(now).toISOString());\n    } else if (certTime.getTime() > fiveMinutesFromNow) {\n      throw new CertificateVerificationError('Certificate is signed more than 5 minutes in the future. Certificate time: ' + certTime.toISOString() + ' Current time: ' + new Date(now).toISOString());\n    }\n    try {\n      sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n    } catch (err) {\n      sigVer = false;\n    }\n    if (!sigVer) {\n      throw new CertificateVerificationError('Signature verification failed');\n    }\n  }\n  async _checkDelegationAndGetKey(d) {\n    if (!d) {\n      return this._rootKey;\n    }\n    const cert = await Certificate.create({\n      certificate: d.certificate,\n      rootKey: this._rootKey,\n      canisterId: this._canisterId,\n      blsVerify: this._blsVerify,\n      // Maximum age of 30 days for delegation certificates\n      maxAgeInMinutes: 60 * 24 * 30\n    });\n    const rangeLookup = cert.lookup(['subnet', d.subnet_id, 'canister_ranges']);\n    if (!rangeLookup) {\n      throw new CertificateVerificationError(`Could not find canister ranges for subnet 0x${toHex(d.subnet_id)}`);\n    }\n    const ranges_arr = cbor.decode(rangeLookup);\n    const ranges = ranges_arr.map(v => [Principal.fromUint8Array(v[0]), Principal.fromUint8Array(v[1])]);\n    const canisterInRange = ranges.some(r => r[0].ltEq(this._canisterId) && r[1].gtEq(this._canisterId));\n    if (!canisterInRange) {\n      throw new CertificateVerificationError(`Canister ${this._canisterId} not in range of delegations for subnet 0x${toHex(d.subnet_id)}`);\n    }\n    const publicKeyLookup = cert.lookup(['subnet', d.subnet_id, 'public_key']);\n    if (!publicKeyLookup) {\n      throw new Error(`Could not find subnet key for subnet 0x${toHex(d.subnet_id)}`);\n    }\n    return publicKeyLookup;\n  }\n}\nconst DER_PREFIX = fromHex('308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100');\nconst KEY_LENGTH = 96;\nfunction extractDER(buf) {\n  const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n  if (buf.byteLength !== expectedLength) {\n    throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);\n  }\n  const prefix = buf.slice(0, DER_PREFIX.byteLength);\n  if (!isBufferEqual(prefix, DER_PREFIX)) {\n    throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`);\n  }\n  return buf.slice(DER_PREFIX.byteLength);\n}\n/**\n * @param t\n */\nexport async function reconstruct(t) {\n  switch (t[0]) {\n    case 0 /* NodeId.Empty */:\n      return hash(domain_sep('ic-hashtree-empty'));\n    case 4 /* NodeId.Pruned */:\n      return t[1];\n    case 3 /* NodeId.Leaf */:\n      return hash(concat(domain_sep('ic-hashtree-leaf'), t[1]));\n    case 2 /* NodeId.Labeled */:\n      return hash(concat(domain_sep('ic-hashtree-labeled'), t[1], await reconstruct(t[2])));\n    case 1 /* NodeId.Fork */:\n      return hash(concat(domain_sep('ic-hashtree-fork'), await reconstruct(t[1]), await reconstruct(t[2])));\n    default:\n      throw new Error('unreachable');\n  }\n}\nfunction domain_sep(s) {\n  const len = new Uint8Array([s.length]);\n  const str = new TextEncoder().encode(s);\n  return concat(len, str);\n}\n/**\n * @param path\n * @param tree\n */\nexport function lookup_path(path, tree) {\n  if (path.length === 0) {\n    switch (tree[0]) {\n      case 3 /* NodeId.Leaf */:\n        {\n          return new Uint8Array(tree[1]).buffer;\n        }\n      default:\n        {\n          return undefined;\n        }\n    }\n  }\n  const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];\n  const t = find_label(label, flatten_forks(tree));\n  if (t) {\n    return lookup_path(path.slice(1), t);\n  }\n}\nfunction flatten_forks(t) {\n  switch (t[0]) {\n    case 0 /* NodeId.Empty */:\n      return [];\n    case 1 /* NodeId.Fork */:\n      return flatten_forks(t[1]).concat(flatten_forks(t[2]));\n    default:\n      return [t];\n  }\n}\nfunction find_label(l, trees) {\n  if (trees.length === 0) {\n    return undefined;\n  }\n  for (const t of trees) {\n    if (t[0] === 2 /* NodeId.Labeled */) {\n      const p = t[1];\n      if (isBufferEqual(l, p)) {\n        return t[2];\n      }\n    }\n  }\n}","map":{"version":3,"names":["cbor","AgentError","hash","concat","fromHex","toHex","Principal","bls","decodeTime","CertificateVerificationError","constructor","reason","hashTreeToString","tree","indent","s","split","map","x","join","labelToString","label","decoder","TextDecoder","undefined","fatal","JSON","stringify","decode","e","byteLength","left","right","sub","Uint8Array","isBufferEqual","a","b","a8","b8","i","length","Certificate","certificate","_rootKey","_canisterId","_blsVerify","_maxAgeInMinutes","arguments","cert","create","options","blsVerify","rootKey","canisterId","maxAgeInMinutes","verify","lookup","path","lookup_path","rootHash","reconstruct","derKey","_checkDelegationAndGetKey","delegation","sig","signature","key","extractDER","msg","domain_sep","sigVer","lookupTime","FIVE_MINUTES_IN_MSEC","MAX_AGE_IN_MSEC","now","Date","earliestCertificateTime","fiveMinutesFromNow","certTime","getTime","toISOString","err","d","rangeLookup","subnet_id","ranges_arr","ranges","v","fromUint8Array","canisterInRange","some","r","ltEq","gtEq","publicKeyLookup","Error","DER_PREFIX","KEY_LENGTH","buf","expectedLength","TypeError","prefix","slice","t","len","str","TextEncoder","encode","buffer","find_label","flatten_forks","l","trees","p"],"sources":["/Users/ridhoauliarahman/Library/CloudStorage/GoogleDrive-ridho.aulia7324@gmail.com/My Drive/ICP/icp-chat-app/src/frontend/node_modules/@dfinity/agent/src/certificate.ts"],"sourcesContent":["import * as cbor from './cbor';\nimport { AgentError } from './errors';\nimport { hash } from './request_id';\nimport { concat, fromHex, toHex } from './utils/buffer';\nimport { Principal } from '@dfinity/principal';\nimport * as bls from './utils/bls';\nimport { decodeTime } from './utils/leb';\n\n/**\n * A certificate may fail verification with respect to the provided public key\n */\nexport class CertificateVerificationError extends AgentError {\n  constructor(reason: string) {\n    super(`Invalid certificate: ${reason}`);\n  }\n}\n\ninterface Cert {\n  tree: HashTree;\n  signature: ArrayBuffer;\n  delegation?: Delegation;\n}\n\nconst enum NodeId {\n  Empty = 0,\n  Fork = 1,\n  Labeled = 2,\n  Leaf = 3,\n  Pruned = 4,\n}\n\nexport type HashTree =\n  | [NodeId.Empty]\n  | [NodeId.Fork, HashTree, HashTree]\n  | [NodeId.Labeled, ArrayBuffer, HashTree]\n  | [NodeId.Leaf, ArrayBuffer]\n  | [NodeId.Pruned, ArrayBuffer];\n\n/**\n * Make a human readable string out of a hash tree.\n * @param tree\n */\nexport function hashTreeToString(tree: HashTree): string {\n  const indent = (s: string) =>\n    s\n      .split('\\n')\n      .map(x => '  ' + x)\n      .join('\\n');\n  function labelToString(label: ArrayBuffer): string {\n    const decoder = new TextDecoder(undefined, { fatal: true });\n    try {\n      return JSON.stringify(decoder.decode(label));\n    } catch (e) {\n      return `data(...${label.byteLength} bytes)`;\n    }\n  }\n\n  switch (tree[0]) {\n    case NodeId.Empty:\n      return '()';\n    case NodeId.Fork: {\n      const left = hashTreeToString(tree[1]);\n      const right = hashTreeToString(tree[2]);\n      return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n    }\n    case NodeId.Labeled: {\n      const label = labelToString(tree[1]);\n      const sub = hashTreeToString(tree[2]);\n      return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n    }\n    case NodeId.Leaf: {\n      return `leaf(...${tree[1].byteLength} bytes)`;\n    }\n    case NodeId.Pruned: {\n      return `pruned(${toHex(new Uint8Array(tree[1]))}`;\n    }\n    default: {\n      return `unknown(${JSON.stringify(tree[0])})`;\n    }\n  }\n}\n\ninterface Delegation extends Record<string, any> {\n  subnet_id: ArrayBuffer;\n  certificate: ArrayBuffer;\n}\n\nfunction isBufferEqual(a: ArrayBuffer, b: ArrayBuffer): boolean {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  const a8 = new Uint8Array(a);\n  const b8 = new Uint8Array(b);\n  for (let i = 0; i < a8.length; i++) {\n    if (a8[i] !== b8[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\ntype VerifyFunc = (pk: Uint8Array, sig: Uint8Array, msg: Uint8Array) => Promise<boolean>;\n\nexport interface CreateCertificateOptions {\n  /**\n   * The bytes encoding the certificate to be verified\n   */\n  certificate: ArrayBuffer;\n  /**\n   * The root key against which to verify the certificate\n   * (normally, the root key of the IC main network)\n   */\n  rootKey: ArrayBuffer;\n  /**\n   * The effective canister ID of the request when verifying a response, or\n   * the signing canister ID when verifying a certified variable.\n   */\n  canisterId: Principal;\n  /**\n   * BLS Verification strategy. Default strategy uses wasm for performance, but that may not be available in all contexts.\n   */\n  blsVerify?: VerifyFunc;\n\n  /**\n   * The maximum age of the certificate in minutes. Default is 5 minutes.\n   * @default 5\n   * This is used to verify the time the certificate was signed, particularly for validating Delegation certificates, which can live for longer than the default window of +/- 5 minutes. If the certificate is\n   * older than the specified age, it will fail verification.\n   */\n  maxAgeInMinutes?: number;\n}\n\nexport class Certificate {\n  private readonly cert: Cert;\n\n  /**\n   * Create a new instance of a certificate, automatically verifying it. Throws a\n   * CertificateVerificationError if the certificate cannot be verified.\n   * @constructs  Certificate\n   * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}\n   * @param {ArrayBuffer} options.certificate The bytes of the certificate\n   * @param {ArrayBuffer} options.rootKey The root key to verify against\n   * @param {Principal} options.canisterId The effective or signing canister ID\n   * @param {number} options.maxAgeInMinutes The maximum age of the certificate in minutes. Default is 5 minutes.\n   * @throws {CertificateVerificationError}\n   */\n  public static async create(options: CreateCertificateOptions): Promise<Certificate> {\n    let blsVerify = options.blsVerify;\n    if (!blsVerify) {\n      blsVerify = bls.blsVerify;\n    }\n    const cert = new Certificate(\n      options.certificate,\n      options.rootKey,\n      options.canisterId,\n      blsVerify,\n      options.maxAgeInMinutes,\n    );\n    await cert.verify();\n    return cert;\n  }\n\n  private constructor(\n    certificate: ArrayBuffer,\n    private _rootKey: ArrayBuffer,\n    private _canisterId: Principal,\n    private _blsVerify: VerifyFunc,\n    // Default to 5 minutes\n    private _maxAgeInMinutes: number = 5,\n  ) {\n    this.cert = cbor.decode(new Uint8Array(certificate));\n  }\n\n  public lookup(path: Array<ArrayBuffer | string>): ArrayBuffer | undefined {\n    return lookup_path(path, this.cert.tree);\n  }\n\n  private async verify(): Promise<void> {\n    const rootHash = await reconstruct(this.cert.tree);\n    const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);\n    const sig = this.cert.signature;\n    const key = extractDER(derKey);\n    const msg = concat(domain_sep('ic-state-root'), rootHash);\n    let sigVer = false;\n\n    const lookupTime = this.lookup(['time']);\n    if (!lookupTime) {\n      // Should never happen - time is always present in IC certificates\n      throw new CertificateVerificationError('Certificate does not contain a time');\n    }\n\n    const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n    const MAX_AGE_IN_MSEC = this._maxAgeInMinutes * 60 * 1000;\n    const now = Date.now();\n    const earliestCertificateTime = now - MAX_AGE_IN_MSEC;\n    const fiveMinutesFromNow = now + FIVE_MINUTES_IN_MSEC;\n\n    const certTime = decodeTime(lookupTime);\n\n    if (certTime.getTime() < earliestCertificateTime) {\n      throw new CertificateVerificationError(\n        `Certificate is signed more than ${this._maxAgeInMinutes} minutes in the past. Certificate time: ` +\n          certTime.toISOString() +\n          ' Current time: ' +\n          new Date(now).toISOString(),\n      );\n    } else if (certTime.getTime() > fiveMinutesFromNow) {\n      throw new CertificateVerificationError(\n        'Certificate is signed more than 5 minutes in the future. Certificate time: ' +\n          certTime.toISOString() +\n          ' Current time: ' +\n          new Date(now).toISOString(),\n      );\n    }\n\n    try {\n      sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n    } catch (err) {\n      sigVer = false;\n    }\n    if (!sigVer) {\n      throw new CertificateVerificationError('Signature verification failed');\n    }\n  }\n\n  private async _checkDelegationAndGetKey(d?: Delegation): Promise<ArrayBuffer> {\n    if (!d) {\n      return this._rootKey;\n    }\n\n    const cert: Certificate = await Certificate.create({\n      certificate: d.certificate,\n      rootKey: this._rootKey,\n      canisterId: this._canisterId,\n      blsVerify: this._blsVerify,\n      // Maximum age of 30 days for delegation certificates\n      maxAgeInMinutes: 60 * 24 * 30,\n    });\n\n    const rangeLookup = cert.lookup(['subnet', d.subnet_id, 'canister_ranges']);\n    if (!rangeLookup) {\n      throw new CertificateVerificationError(\n        `Could not find canister ranges for subnet 0x${toHex(d.subnet_id)}`,\n      );\n    }\n    const ranges_arr: Array<[Uint8Array, Uint8Array]> = cbor.decode(rangeLookup);\n    const ranges: Array<[Principal, Principal]> = ranges_arr.map(v => [\n      Principal.fromUint8Array(v[0]),\n      Principal.fromUint8Array(v[1]),\n    ]);\n\n    const canisterInRange = ranges.some(\n      r => r[0].ltEq(this._canisterId) && r[1].gtEq(this._canisterId),\n    );\n    if (!canisterInRange) {\n      throw new CertificateVerificationError(\n        `Canister ${this._canisterId} not in range of delegations for subnet 0x${toHex(\n          d.subnet_id,\n        )}`,\n      );\n    }\n    const publicKeyLookup = cert.lookup(['subnet', d.subnet_id, 'public_key']);\n    if (!publicKeyLookup) {\n      throw new Error(`Could not find subnet key for subnet 0x${toHex(d.subnet_id)}`);\n    }\n    return publicKeyLookup;\n  }\n}\n\nconst DER_PREFIX = fromHex(\n  '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100',\n);\nconst KEY_LENGTH = 96;\n\nfunction extractDER(buf: ArrayBuffer): ArrayBuffer {\n  const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n  if (buf.byteLength !== expectedLength) {\n    throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);\n  }\n  const prefix = buf.slice(0, DER_PREFIX.byteLength);\n  if (!isBufferEqual(prefix, DER_PREFIX)) {\n    throw new TypeError(\n      `BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`,\n    );\n  }\n\n  return buf.slice(DER_PREFIX.byteLength);\n}\n\n/**\n * @param t\n */\nexport async function reconstruct(t: HashTree): Promise<ArrayBuffer> {\n  switch (t[0]) {\n    case NodeId.Empty:\n      return hash(domain_sep('ic-hashtree-empty'));\n    case NodeId.Pruned:\n      return t[1] as ArrayBuffer;\n    case NodeId.Leaf:\n      return hash(concat(domain_sep('ic-hashtree-leaf'), t[1] as ArrayBuffer));\n    case NodeId.Labeled:\n      return hash(\n        concat(\n          domain_sep('ic-hashtree-labeled'),\n          t[1] as ArrayBuffer,\n          await reconstruct(t[2] as HashTree),\n        ),\n      );\n    case NodeId.Fork:\n      return hash(\n        concat(\n          domain_sep('ic-hashtree-fork'),\n          await reconstruct(t[1] as HashTree),\n          await reconstruct(t[2] as HashTree),\n        ),\n      );\n    default:\n      throw new Error('unreachable');\n  }\n}\n\nfunction domain_sep(s: string): ArrayBuffer {\n  const len = new Uint8Array([s.length]);\n  const str = new TextEncoder().encode(s);\n  return concat(len, str);\n}\n\n/**\n * @param path\n * @param tree\n */\nexport function lookup_path(\n  path: Array<ArrayBuffer | string>,\n  tree: HashTree,\n): ArrayBuffer | undefined {\n  if (path.length === 0) {\n    switch (tree[0]) {\n      case NodeId.Leaf: {\n        return new Uint8Array(tree[1]).buffer;\n      }\n      default: {\n        return undefined;\n      }\n    }\n  }\n\n  const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];\n  const t = find_label(label, flatten_forks(tree));\n  if (t) {\n    return lookup_path(path.slice(1), t);\n  }\n}\nfunction flatten_forks(t: HashTree): HashTree[] {\n  switch (t[0]) {\n    case NodeId.Empty:\n      return [];\n    case NodeId.Fork:\n      return flatten_forks(t[1] as HashTree).concat(flatten_forks(t[2] as HashTree));\n    default:\n      return [t];\n  }\n}\nfunction find_label(l: ArrayBuffer, trees: HashTree[]): HashTree | undefined {\n  if (trees.length === 0) {\n    return undefined;\n  }\n  for (const t of trees) {\n    if (t[0] === NodeId.Labeled) {\n      const p = t[1] as ArrayBuffer;\n      if (isBufferEqual(l, p)) {\n        return t[2];\n      }\n    }\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,IAAI,MAAM,QAAQ;AAC9B,SAASC,UAAU,QAAQ,UAAU;AACrC,SAASC,IAAI,QAAQ,cAAc;AACnC,SAASC,MAAM,EAAEC,OAAO,EAAEC,KAAK,QAAQ,gBAAgB;AACvD,SAASC,SAAS,QAAQ,oBAAoB;AAC9C,OAAO,KAAKC,GAAG,MAAM,aAAa;AAClC,SAASC,UAAU,QAAQ,aAAa;AAExC;;;AAGA,OAAM,MAAOC,4BAA6B,SAAQR,UAAU;EAC1DS,YAAYC,MAAc;IACxB,KAAK,CAAC,wBAAwBA,MAAM,EAAE,CAAC;EACzC;;AAwBF;;;;AAIA,OAAM,SAAUC,gBAAgBA,CAACC,IAAc;EAC7C,MAAMC,MAAM,GAAIC,CAAS,IACvBA,CAAC,CACEC,KAAK,CAAC,IAAI,CAAC,CACXC,GAAG,CAACC,CAAC,IAAI,IAAI,GAAGA,CAAC,CAAC,CAClBC,IAAI,CAAC,IAAI,CAAC;EACf,SAASC,aAAaA,CAACC,KAAkB;IACvC,MAAMC,OAAO,GAAG,IAAIC,WAAW,CAACC,SAAS,EAAE;MAAEC,KAAK,EAAE;IAAI,CAAE,CAAC;IAC3D,IAAI;MACF,OAAOC,IAAI,CAACC,SAAS,CAACL,OAAO,CAACM,MAAM,CAACP,KAAK,CAAC,CAAC;KAC7C,CAAC,OAAOQ,CAAC,EAAE;MACV,OAAO,WAAWR,KAAK,CAACS,UAAU,SAAS;;EAE/C;EAEA,QAAQjB,IAAI,CAAC,CAAC,CAAC;IACb;MACE,OAAO,IAAI;IACb;MAAkB;QAChB,MAAMkB,IAAI,GAAGnB,gBAAgB,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC;QACtC,MAAMmB,KAAK,GAAGpB,gBAAgB,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC;QACvC,OAAO,iBAAiBC,MAAM,CAACiB,IAAI,CAAC,mBAAmBjB,MAAM,CAACkB,KAAK,CAAC,KAAK;;IAE3E;MAAqB;QACnB,MAAMX,KAAK,GAAGD,aAAa,CAACP,IAAI,CAAC,CAAC,CAAC,CAAC;QACpC,MAAMoB,GAAG,GAAGrB,gBAAgB,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC;QACrC,OAAO,oBAAoBC,MAAM,CAACO,KAAK,CAAC,YAAYP,MAAM,CAACmB,GAAG,CAAC,KAAK;;IAEtE;MAAkB;QAChB,OAAO,WAAWpB,IAAI,CAAC,CAAC,CAAC,CAACiB,UAAU,SAAS;;IAE/C;MAAoB;QAClB,OAAO,UAAUzB,KAAK,CAAC,IAAI6B,UAAU,CAACrB,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;;IAEnD;MAAS;QACP,OAAO,WAAWa,IAAI,CAACC,SAAS,CAACd,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG;;;AAGlD;AAOA,SAASsB,aAAaA,CAACC,CAAc,EAAEC,CAAc;EACnD,IAAID,CAAC,CAACN,UAAU,KAAKO,CAAC,CAACP,UAAU,EAAE;IACjC,OAAO,KAAK;;EAEd,MAAMQ,EAAE,GAAG,IAAIJ,UAAU,CAACE,CAAC,CAAC;EAC5B,MAAMG,EAAE,GAAG,IAAIL,UAAU,CAACG,CAAC,CAAC;EAC5B,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,EAAE,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;IAClC,IAAIF,EAAE,CAACE,CAAC,CAAC,KAAKD,EAAE,CAACC,CAAC,CAAC,EAAE;MACnB,OAAO,KAAK;;;EAGhB,OAAO,IAAI;AACb;AAiCA,OAAM,MAAOE,WAAW;EA8BtBhC,YACEiC,WAAwB,EAChBC,QAAqB,EACrBC,WAAsB,EACtBC,UAAsB,EAEM;IAAA,IAA5BC,gBAAA,GAAAC,SAAA,CAAAP,MAAA,QAAAO,SAAA,QAAAxB,SAAA,GAAAwB,SAAA,MAA2B,CAAC;IAJ5B,KAAAJ,QAAQ,GAARA,QAAQ;IACR,KAAAC,WAAW,GAAXA,WAAW;IACX,KAAAC,UAAU,GAAVA,UAAU;IAEV,KAAAC,gBAAgB,GAAhBA,gBAAgB;IAExB,IAAI,CAACE,IAAI,GAAGjD,IAAI,CAAC4B,MAAM,CAAC,IAAIM,UAAU,CAACS,WAAW,CAAC,CAAC;EACtD;EApCA;;;;;;;;;;;EAWO,aAAaO,MAAMA,CAACC,OAAiC;IAC1D,IAAIC,SAAS,GAAGD,OAAO,CAACC,SAAS;IACjC,IAAI,CAACA,SAAS,EAAE;MACdA,SAAS,GAAG7C,GAAG,CAAC6C,SAAS;;IAE3B,MAAMH,IAAI,GAAG,IAAIP,WAAW,CAC1BS,OAAO,CAACR,WAAW,EACnBQ,OAAO,CAACE,OAAO,EACfF,OAAO,CAACG,UAAU,EAClBF,SAAS,EACTD,OAAO,CAACI,eAAe,CACxB;IACD,MAAMN,IAAI,CAACO,MAAM,EAAE;IACnB,OAAOP,IAAI;EACb;EAaOQ,MAAMA,CAACC,IAAiC;IAC7C,OAAOC,WAAW,CAACD,IAAI,EAAE,IAAI,CAACT,IAAI,CAACpC,IAAI,CAAC;EAC1C;EAEQ,MAAM2C,MAAMA,CAAA;IAClB,MAAMI,QAAQ,GAAG,MAAMC,WAAW,CAAC,IAAI,CAACZ,IAAI,CAACpC,IAAI,CAAC;IAClD,MAAMiD,MAAM,GAAG,MAAM,IAAI,CAACC,yBAAyB,CAAC,IAAI,CAACd,IAAI,CAACe,UAAU,CAAC;IACzE,MAAMC,GAAG,GAAG,IAAI,CAAChB,IAAI,CAACiB,SAAS;IAC/B,MAAMC,GAAG,GAAGC,UAAU,CAACN,MAAM,CAAC;IAC9B,MAAMO,GAAG,GAAGlE,MAAM,CAACmE,UAAU,CAAC,eAAe,CAAC,EAAEV,QAAQ,CAAC;IACzD,IAAIW,MAAM,GAAG,KAAK;IAElB,MAAMC,UAAU,GAAG,IAAI,CAACf,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC;IACxC,IAAI,CAACe,UAAU,EAAE;MACf;MACA,MAAM,IAAI/D,4BAA4B,CAAC,qCAAqC,CAAC;;IAG/E,MAAMgE,oBAAoB,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI;IAC1C,MAAMC,eAAe,GAAG,IAAI,CAAC3B,gBAAgB,GAAG,EAAE,GAAG,IAAI;IACzD,MAAM4B,GAAG,GAAGC,IAAI,CAACD,GAAG,EAAE;IACtB,MAAME,uBAAuB,GAAGF,GAAG,GAAGD,eAAe;IACrD,MAAMI,kBAAkB,GAAGH,GAAG,GAAGF,oBAAoB;IAErD,MAAMM,QAAQ,GAAGvE,UAAU,CAACgE,UAAU,CAAC;IAEvC,IAAIO,QAAQ,CAACC,OAAO,EAAE,GAAGH,uBAAuB,EAAE;MAChD,MAAM,IAAIpE,4BAA4B,CACpC,mCAAmC,IAAI,CAACsC,gBAAgB,0CAA0C,GAChGgC,QAAQ,CAACE,WAAW,EAAE,GACtB,iBAAiB,GACjB,IAAIL,IAAI,CAACD,GAAG,CAAC,CAACM,WAAW,EAAE,CAC9B;KACF,MAAM,IAAIF,QAAQ,CAACC,OAAO,EAAE,GAAGF,kBAAkB,EAAE;MAClD,MAAM,IAAIrE,4BAA4B,CACpC,6EAA6E,GAC3EsE,QAAQ,CAACE,WAAW,EAAE,GACtB,iBAAiB,GACjB,IAAIL,IAAI,CAACD,GAAG,CAAC,CAACM,WAAW,EAAE,CAC9B;;IAGH,IAAI;MACFV,MAAM,GAAG,MAAM,IAAI,CAACzB,UAAU,CAAC,IAAIZ,UAAU,CAACiC,GAAG,CAAC,EAAE,IAAIjC,UAAU,CAAC+B,GAAG,CAAC,EAAE,IAAI/B,UAAU,CAACmC,GAAG,CAAC,CAAC;KAC9F,CAAC,OAAOa,GAAG,EAAE;MACZX,MAAM,GAAG,KAAK;;IAEhB,IAAI,CAACA,MAAM,EAAE;MACX,MAAM,IAAI9D,4BAA4B,CAAC,+BAA+B,CAAC;;EAE3E;EAEQ,MAAMsD,yBAAyBA,CAACoB,CAAc;IACpD,IAAI,CAACA,CAAC,EAAE;MACN,OAAO,IAAI,CAACvC,QAAQ;;IAGtB,MAAMK,IAAI,GAAgB,MAAMP,WAAW,CAACQ,MAAM,CAAC;MACjDP,WAAW,EAAEwC,CAAC,CAACxC,WAAW;MAC1BU,OAAO,EAAE,IAAI,CAACT,QAAQ;MACtBU,UAAU,EAAE,IAAI,CAACT,WAAW;MAC5BO,SAAS,EAAE,IAAI,CAACN,UAAU;MAC1B;MACAS,eAAe,EAAE,EAAE,GAAG,EAAE,GAAG;KAC5B,CAAC;IAEF,MAAM6B,WAAW,GAAGnC,IAAI,CAACQ,MAAM,CAAC,CAAC,QAAQ,EAAE0B,CAAC,CAACE,SAAS,EAAE,iBAAiB,CAAC,CAAC;IAC3E,IAAI,CAACD,WAAW,EAAE;MAChB,MAAM,IAAI3E,4BAA4B,CACpC,+CAA+CJ,KAAK,CAAC8E,CAAC,CAACE,SAAS,CAAC,EAAE,CACpE;;IAEH,MAAMC,UAAU,GAAoCtF,IAAI,CAAC4B,MAAM,CAACwD,WAAW,CAAC;IAC5E,MAAMG,MAAM,GAAkCD,UAAU,CAACrE,GAAG,CAACuE,CAAC,IAAI,CAChElF,SAAS,CAACmF,cAAc,CAACD,CAAC,CAAC,CAAC,CAAC,CAAC,EAC9BlF,SAAS,CAACmF,cAAc,CAACD,CAAC,CAAC,CAAC,CAAC,CAAC,CAC/B,CAAC;IAEF,MAAME,eAAe,GAAGH,MAAM,CAACI,IAAI,CACjCC,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAChD,WAAW,CAAC,IAAI+C,CAAC,CAAC,CAAC,CAAC,CAACE,IAAI,CAAC,IAAI,CAACjD,WAAW,CAAC,CAChE;IACD,IAAI,CAAC6C,eAAe,EAAE;MACpB,MAAM,IAAIjF,4BAA4B,CACpC,YAAY,IAAI,CAACoC,WAAW,6CAA6CxC,KAAK,CAC5E8E,CAAC,CAACE,SAAS,CACZ,EAAE,CACJ;;IAEH,MAAMU,eAAe,GAAG9C,IAAI,CAACQ,MAAM,CAAC,CAAC,QAAQ,EAAE0B,CAAC,CAACE,SAAS,EAAE,YAAY,CAAC,CAAC;IAC1E,IAAI,CAACU,eAAe,EAAE;MACpB,MAAM,IAAIC,KAAK,CAAC,0CAA0C3F,KAAK,CAAC8E,CAAC,CAACE,SAAS,CAAC,EAAE,CAAC;;IAEjF,OAAOU,eAAe;EACxB;;AAGF,MAAME,UAAU,GAAG7F,OAAO,CACxB,4EAA4E,CAC7E;AACD,MAAM8F,UAAU,GAAG,EAAE;AAErB,SAAS9B,UAAUA,CAAC+B,GAAgB;EAClC,MAAMC,cAAc,GAAGH,UAAU,CAACnE,UAAU,GAAGoE,UAAU;EACzD,IAAIC,GAAG,CAACrE,UAAU,KAAKsE,cAAc,EAAE;IACrC,MAAM,IAAIC,SAAS,CAAC,sCAAsCD,cAAc,aAAa,CAAC;;EAExF,MAAME,MAAM,GAAGH,GAAG,CAACI,KAAK,CAAC,CAAC,EAAEN,UAAU,CAACnE,UAAU,CAAC;EAClD,IAAI,CAACK,aAAa,CAACmE,MAAM,EAAEL,UAAU,CAAC,EAAE;IACtC,MAAM,IAAII,SAAS,CACjB,uEAAuEJ,UAAU,aAAaK,MAAM,EAAE,CACvG;;EAGH,OAAOH,GAAG,CAACI,KAAK,CAACN,UAAU,CAACnE,UAAU,CAAC;AACzC;AAEA;;;AAGA,OAAO,eAAe+B,WAAWA,CAAC2C,CAAW;EAC3C,QAAQA,CAAC,CAAC,CAAC,CAAC;IACV;MACE,OAAOtG,IAAI,CAACoE,UAAU,CAAC,mBAAmB,CAAC,CAAC;IAC9C;MACE,OAAOkC,CAAC,CAAC,CAAC,CAAgB;IAC5B;MACE,OAAOtG,IAAI,CAACC,MAAM,CAACmE,UAAU,CAAC,kBAAkB,CAAC,EAAEkC,CAAC,CAAC,CAAC,CAAgB,CAAC,CAAC;IAC1E;MACE,OAAOtG,IAAI,CACTC,MAAM,CACJmE,UAAU,CAAC,qBAAqB,CAAC,EACjCkC,CAAC,CAAC,CAAC,CAAgB,EACnB,MAAM3C,WAAW,CAAC2C,CAAC,CAAC,CAAC,CAAa,CAAC,CACpC,CACF;IACH;MACE,OAAOtG,IAAI,CACTC,MAAM,CACJmE,UAAU,CAAC,kBAAkB,CAAC,EAC9B,MAAMT,WAAW,CAAC2C,CAAC,CAAC,CAAC,CAAa,CAAC,EACnC,MAAM3C,WAAW,CAAC2C,CAAC,CAAC,CAAC,CAAa,CAAC,CACpC,CACF;IACH;MACE,MAAM,IAAIR,KAAK,CAAC,aAAa,CAAC;;AAEpC;AAEA,SAAS1B,UAAUA,CAACvD,CAAS;EAC3B,MAAM0F,GAAG,GAAG,IAAIvE,UAAU,CAAC,CAACnB,CAAC,CAAC0B,MAAM,CAAC,CAAC;EACtC,MAAMiE,GAAG,GAAG,IAAIC,WAAW,EAAE,CAACC,MAAM,CAAC7F,CAAC,CAAC;EACvC,OAAOZ,MAAM,CAACsG,GAAG,EAAEC,GAAG,CAAC;AACzB;AAEA;;;;AAIA,OAAM,SAAU/C,WAAWA,CACzBD,IAAiC,EACjC7C,IAAc;EAEd,IAAI6C,IAAI,CAACjB,MAAM,KAAK,CAAC,EAAE;IACrB,QAAQ5B,IAAI,CAAC,CAAC,CAAC;MACb;QAAkB;UAChB,OAAO,IAAIqB,UAAU,CAACrB,IAAI,CAAC,CAAC,CAAC,CAAC,CAACgG,MAAM;;MAEvC;QAAS;UACP,OAAOrF,SAAS;;;;EAKtB,MAAMH,KAAK,GAAG,OAAOqC,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,GAAG,IAAIiD,WAAW,EAAE,CAACC,MAAM,CAAClD,IAAI,CAAC,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;EACvF,MAAM8C,CAAC,GAAGM,UAAU,CAACzF,KAAK,EAAE0F,aAAa,CAAClG,IAAI,CAAC,CAAC;EAChD,IAAI2F,CAAC,EAAE;IACL,OAAO7C,WAAW,CAACD,IAAI,CAAC6C,KAAK,CAAC,CAAC,CAAC,EAAEC,CAAC,CAAC;;AAExC;AACA,SAASO,aAAaA,CAACP,CAAW;EAChC,QAAQA,CAAC,CAAC,CAAC,CAAC;IACV;MACE,OAAO,EAAE;IACX;MACE,OAAOO,aAAa,CAACP,CAAC,CAAC,CAAC,CAAa,CAAC,CAACrG,MAAM,CAAC4G,aAAa,CAACP,CAAC,CAAC,CAAC,CAAa,CAAC,CAAC;IAChF;MACE,OAAO,CAACA,CAAC,CAAC;;AAEhB;AACA,SAASM,UAAUA,CAACE,CAAc,EAAEC,KAAiB;EACnD,IAAIA,KAAK,CAACxE,MAAM,KAAK,CAAC,EAAE;IACtB,OAAOjB,SAAS;;EAElB,KAAK,MAAMgF,CAAC,IAAIS,KAAK,EAAE;IACrB,IAAIT,CAAC,CAAC,CAAC,CAAC,6BAAqB;MAC3B,MAAMU,CAAC,GAAGV,CAAC,CAAC,CAAC,CAAgB;MAC7B,IAAIrE,aAAa,CAAC6E,CAAC,EAAEE,CAAC,CAAC,EAAE;QACvB,OAAOV,CAAC,CAAC,CAAC,CAAC;;;;AAInB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}