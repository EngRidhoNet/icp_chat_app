{"ast":null,"code":"import { lebEncode } from '@dfinity/candid';\nimport * as cbor from 'simple-cbor';\nimport { makeNonce } from './types';\nconst NANOSECONDS_PER_MILLISECONDS = BigInt(1000000);\nconst REPLICA_PERMITTED_DRIFT_MILLISECONDS = BigInt(60 * 1000);\nexport class Expiry {\n  constructor(deltaInMSec) {\n    // Use bigint because it can overflow the maximum number allowed in a double float.\n    this._value = (BigInt(Date.now()) + BigInt(deltaInMSec) - REPLICA_PERMITTED_DRIFT_MILLISECONDS) * NANOSECONDS_PER_MILLISECONDS;\n  }\n  toCBOR() {\n    // TODO: change this to take the minimum amount of space (it always takes 8 bytes now).\n    return cbor.value.u64(this._value.toString(16), 16);\n  }\n  toHash() {\n    return lebEncode(this._value);\n  }\n}\n/**\n * Create a Nonce transform, which takes a function that returns a Buffer, and adds it\n * as the nonce to every call requests.\n * @param nonceFn A function that returns a buffer. By default uses a semi-random method.\n */\nexport function makeNonceTransform() {\n  let nonceFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : makeNonce;\n  return async request => {\n    const nonce = nonceFn();\n    // Nonce needs to be inserted into the header for all requests, to enable logs to be correlated with requests.\n    const headers = request.request.headers;\n    // TODO: uncomment this when the http proxy supports it.\n    // headers.set('X-IC-Request-ID', toHex(new Uint8Array(nonce)));\n    request.request.headers = headers;\n    // Nonce only needs to be inserted into the body for async calls, to prevent replay attacks.\n    if (request.endpoint === \"call\" /* Endpoint.Call */) {\n      request.body.nonce = nonceFn();\n    }\n  };\n}\n/**\n * Create a transform that adds a delay (by default 5 minutes) to the expiry.\n *\n * @param delayInMilliseconds The delay to add to the call time, in milliseconds.\n */\nexport function makeExpiryTransform(delayInMilliseconds) {\n  return async request => {\n    request.body.ingress_expiry = new Expiry(delayInMilliseconds);\n  };\n}\n/**\n * Maps the default fetch headers field to the serializable HttpHeaderField.\n *\n * @param headers Fetch definition of the headers type\n * @returns array of header fields\n */\nexport function httpHeadersTransform(headers) {\n  const headerFields = [];\n  headers.forEach((value, key) => {\n    headerFields.push([key, value]);\n  });\n  return headerFields;\n}","map":{"version":3,"names":["lebEncode","cbor","makeNonce","NANOSECONDS_PER_MILLISECONDS","BigInt","REPLICA_PERMITTED_DRIFT_MILLISECONDS","Expiry","constructor","deltaInMSec","_value","Date","now","toCBOR","value","u64","toString","toHash","makeNonceTransform","nonceFn","arguments","length","undefined","request","nonce","headers","endpoint","body","makeExpiryTransform","delayInMilliseconds","ingress_expiry","httpHeadersTransform","headerFields","forEach","key","push"],"sources":["/Users/ridhoauliarahman/Library/CloudStorage/GoogleDrive-ridho.aulia7324@gmail.com/My Drive/ICP/icp-chat-app/src/frontend/node_modules/@dfinity/agent/src/agent/http/transforms.ts"],"sourcesContent":["import { lebEncode } from '@dfinity/candid';\nimport * as cbor from 'simple-cbor';\nimport {\n  Endpoint,\n  HttpAgentRequest,\n  HttpAgentRequestTransformFn,\n  HttpHeaderField,\n  makeNonce,\n  Nonce,\n} from './types';\nimport { toHex } from '../../utils/buffer';\n\nconst NANOSECONDS_PER_MILLISECONDS = BigInt(1_000_000);\n\nconst REPLICA_PERMITTED_DRIFT_MILLISECONDS = BigInt(60 * 1000);\n\nexport class Expiry {\n  private readonly _value: bigint;\n\n  constructor(deltaInMSec: number) {\n    // Use bigint because it can overflow the maximum number allowed in a double float.\n    this._value =\n      (BigInt(Date.now()) + BigInt(deltaInMSec) - REPLICA_PERMITTED_DRIFT_MILLISECONDS) *\n      NANOSECONDS_PER_MILLISECONDS;\n  }\n\n  public toCBOR(): cbor.CborValue {\n    // TODO: change this to take the minimum amount of space (it always takes 8 bytes now).\n    return cbor.value.u64(this._value.toString(16), 16);\n  }\n\n  public toHash(): ArrayBuffer {\n    return lebEncode(this._value);\n  }\n}\n\n/**\n * Create a Nonce transform, which takes a function that returns a Buffer, and adds it\n * as the nonce to every call requests.\n * @param nonceFn A function that returns a buffer. By default uses a semi-random method.\n */\nexport function makeNonceTransform(nonceFn: () => Nonce = makeNonce): HttpAgentRequestTransformFn {\n  return async (request: HttpAgentRequest) => {\n    const nonce = nonceFn();\n    // Nonce needs to be inserted into the header for all requests, to enable logs to be correlated with requests.\n    const headers = request.request.headers;\n    // TODO: uncomment this when the http proxy supports it.\n    // headers.set('X-IC-Request-ID', toHex(new Uint8Array(nonce)));\n    request.request.headers = headers;\n\n    // Nonce only needs to be inserted into the body for async calls, to prevent replay attacks.\n    if (request.endpoint === Endpoint.Call) {\n      request.body.nonce = nonceFn();\n    }\n  };\n}\n\n/**\n * Create a transform that adds a delay (by default 5 minutes) to the expiry.\n *\n * @param delayInMilliseconds The delay to add to the call time, in milliseconds.\n */\nexport function makeExpiryTransform(delayInMilliseconds: number): HttpAgentRequestTransformFn {\n  return async (request: HttpAgentRequest) => {\n    request.body.ingress_expiry = new Expiry(delayInMilliseconds);\n  };\n}\n\n/**\n * Maps the default fetch headers field to the serializable HttpHeaderField.\n *\n * @param headers Fetch definition of the headers type\n * @returns array of header fields\n */\nexport function httpHeadersTransform(headers: Headers): HttpHeaderField[] {\n  const headerFields: HttpHeaderField[] = [];\n  headers.forEach((value, key) => {\n    headerFields.push([key, value]);\n  });\n  return headerFields;\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,iBAAiB;AAC3C,OAAO,KAAKC,IAAI,MAAM,aAAa;AACnC,SAKEC,SAAS,QAEJ,SAAS;AAGhB,MAAMC,4BAA4B,GAAGC,MAAM,CAAC,OAAS,CAAC;AAEtD,MAAMC,oCAAoC,GAAGD,MAAM,CAAC,EAAE,GAAG,IAAI,CAAC;AAE9D,OAAM,MAAOE,MAAM;EAGjBC,YAAYC,WAAmB;IAC7B;IACA,IAAI,CAACC,MAAM,GACT,CAACL,MAAM,CAACM,IAAI,CAACC,GAAG,EAAE,CAAC,GAAGP,MAAM,CAACI,WAAW,CAAC,GAAGH,oCAAoC,IAChFF,4BAA4B;EAChC;EAEOS,MAAMA,CAAA;IACX;IACA,OAAOX,IAAI,CAACY,KAAK,CAACC,GAAG,CAAC,IAAI,CAACL,MAAM,CAACM,QAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;EACrD;EAEOC,MAAMA,CAAA;IACX,OAAOhB,SAAS,CAAC,IAAI,CAACS,MAAM,CAAC;EAC/B;;AAGF;;;;;AAKA,OAAM,SAAUQ,kBAAkBA,CAAA,EAAiC;EAAA,IAAhCC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAuBjB,SAAS;EACjE,OAAO,MAAOoB,OAAyB,IAAI;IACzC,MAAMC,KAAK,GAAGL,OAAO,EAAE;IACvB;IACA,MAAMM,OAAO,GAAGF,OAAO,CAACA,OAAO,CAACE,OAAO;IACvC;IACA;IACAF,OAAO,CAACA,OAAO,CAACE,OAAO,GAAGA,OAAO;IAEjC;IACA,IAAIF,OAAO,CAACG,QAAQ,iCAAoB;MACtCH,OAAO,CAACI,IAAI,CAACH,KAAK,GAAGL,OAAO,EAAE;;EAElC,CAAC;AACH;AAEA;;;;;AAKA,OAAM,SAAUS,mBAAmBA,CAACC,mBAA2B;EAC7D,OAAO,MAAON,OAAyB,IAAI;IACzCA,OAAO,CAACI,IAAI,CAACG,cAAc,GAAG,IAAIvB,MAAM,CAACsB,mBAAmB,CAAC;EAC/D,CAAC;AACH;AAEA;;;;;;AAMA,OAAM,SAAUE,oBAAoBA,CAACN,OAAgB;EACnD,MAAMO,YAAY,GAAsB,EAAE;EAC1CP,OAAO,CAACQ,OAAO,CAAC,CAACnB,KAAK,EAAEoB,GAAG,KAAI;IAC7BF,YAAY,CAACG,IAAI,CAAC,CAACD,GAAG,EAAEpB,KAAK,CAAC,CAAC;EACjC,CAAC,CAAC;EACF,OAAOkB,YAAY;AACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}